# 第一部分：虚拟化

虚拟化指操作系统对CPU和内存的抽象，对CPU的抽象指进程，操作系统虚拟化多个CPU，让每个应用程序都认为自己独占了CPU；

对内存的抽象指虚拟内存系统，让每个应用程序都认为自己有很大的内存地址空间。

## 1.抽象：进程

**关键问题：**操作系统如何提供拥有多个CPU的假象？

操作系统通过虚拟化CPU来提供这种假象，通过让一个进程只运行一个时间片，然后切换到线程，这样就提供了多个虚拟CPU的假象，即时分共享技术。

要实现CPU的虚拟化，操作系统需要一些**低级机制**和**高级智能**。

低级机制称为机制，是底层的硬件方法，比如上下文切换，它让操作系统能够停止运行一个程序并切换到另一个。

高级智能称为策略，是操作系统层面的一些算法，比如操作系统对进程的调度策略。

### 1.1进程创建

操作系统运行程序的第一件事是将代码和所有静态数据加载到内存中==，现代操作系统惰性的执行该过程，仅在程序执行期间需要加载的代码和数据片段==

==才会加载，通过分页和交换的机制来实现。==

接着操作系统为栈和堆分配一些内存，栈用来存放局部变量，函数参数和返回地址，堆用于显示调用来动态的分配存储空间

然后操作系统执行一些初始化任务，例如*IO*的任务，在*UNIX*系统中每个进程都有三个文件描述符用于标准输入输出和错误。

最后操作系统启动程序，在*main()*入口处运行。

### 1.2进程状态

简单来说进程可以处于以下三种状态：

* 运行（**running**），进程在CPU上运行
* 就绪（**ready**），进程已准备好运行，但是CPU此时已被占用
* 阻塞（**blocked**），进程执行了某种操作被CPU中断，比如发起IO请求时，会被阻塞。

进程状态跟踪：

| 时间 | 进程1 | 进程2 | 事件        |
| ---- | ----- | ----- | ----------- |
| 1    | 运行  | 就绪  |             |
| 2    | 运行  | 就绪  | 进程1发起IO |
| 3    | 阻塞  | 运行  | 进程1被阻塞 |
| 4    | 阻塞  | 运行  | IO完成      |
| 5    | 就绪  | 运行  |             |
| 6    | 就绪  | 运行  | 进程1完成   |
| 7    | 运行  | 结束  | 进程2完成   |

### 1.3进程数据结构

操作系统有关键的数据来跟踪各种信息，为了跟踪每个进程状态，操作系统会为所有就绪的进程保留某种进程列表，也成为**进程控制块。**

## 2.进程API

**关键问题**：如何创建并控制进程

### 2.1 fork()系统调用

~~~c
int main()
{
	printf("hello world (pid:%d)\n", (int) getpid());
	int rc = fork();
	if(rc == 0){
		printf("hello, I am child (pid:%d)\n",(int) getpid());
	}else{
		printf("hello, I am parent of %d (pid:%d)\n",rc,getpid());
	}
	return 0;
 } 
~~~

通过**fork()**系统调用，操作系统创建了一个几乎一样的程序在执行，它们都从**fork()**系统调用返回，新创建的进程称为子进程，原来的进程称为父进程。

子进程不会从main()函数开始执行，而是直接从**fork()**调用返回，好像是他自己调用了fork()。

通过程序的输出可以知道，父进程从fork调用返回子进程的PID（进程描述符），而子进程返回的值时0。

==在单核的CPU上运行，子进程和父进程的输出顺序是不确定的，CPU调度程序将决定把某个时刻程序被执行。==

### 2.2 wait()系统调用

有时想要父进程等待子进程执行完毕，可以使用wait()系统调用。

~~~c
#include<stdio.h>
#include<stdlib.h>
#include<sys/wait.h> 
#include<unistd.h>

int main()
{
	printf("hello world (pid:%d)\n", (int) getpid());
	int rc = fork();
	if(rc == 0){
		printf("hello, I am child (pid:%d)\n",(int) getpid());
	}else{
		int wc = wait(NULL);
		printf("hello, I am parent of %d (pid:%d)\n",rc,getpid());
	}
	return 0;
 }
~~~

这段代码，子进程总是先输出，这是因为如果父进程先执行会调用wait()被阻塞，直到子进程结束后才会再输出结果

### 2.3 exec()系统调用

fork系统调用只能执行与父进程一模一样的程序，而如果想要执行不同的程序需要exec系统调用。

~~~C
#include<stdio.h>
#include<stdlib.h>
#include<sys/wait.h> 
#include<string.h>
#include<unistd.h>

int main(int argc, char *argv[])
{
	printf("hello world (pid:%d)\n", (int) getpid());
	int rc = fork();
	if(rc == 0){
		printf("hello, I am child (pid:%d)\n",(int) getpid());
		char *myargs[3];
		myargs[0] = strdup("wc");
		myargs[1] = strdup("p3.c");
		myargs[2] = NULL;
		execvp(myargs[0], myargs);
		printf("this shoudln't print out");
	}else{
		int wc = wait(NULL);
		printf("hello, I am parent of %d (pid:%d)\n",rc,getpid());
	}
	return 0;
 }
~~~

对于exec()系统调用，给定可执行程序的名称（wc）和需要的参数（p3.c）后，exec()系统调用会从可执行程序中加载代码和静态数据，并且用它覆写自己的

代码段，堆，栈及其他内存空间也会被初始化，然后操作系统执行该进程，因此exec()系统调用没有创建新的进程，==而是直接将当前运行的程序替换为不同的==

==运行程序==。

### 2.4 为什么这样设计

fork()系统调用和exec()系统调用在实现Shell发挥了重要作用。==这给了shell在fork()之后exec()之前运行一些代码的机会==

一下面条命令为例：

~~~shell
wc p3.c > newfile.txt
~~~

shell是一个用户程序，它等待用户输入，大多数情况下shell可以在文件系统中找到这个可执行程序，调用fork()创建新进程，这条命令统计p3.c文件的字符数重定位输出到newfile.txt文件中，再调用exec()之前会关闭标准输出，打开文件，然后才执行exec()，并调用wait等待该命令完成，最后从wait返回。

## 3.机制：受限直接执行

关键问题：操作系统如何以高性能的方式虚拟化CPU同时保持对系统的控制。

### 3.1直接执行

直接执行的方式很简单，操纵系统从main函数入口处执行程序然后从return中返回。

这样做会产生两个问题：

1. 如何确保程序不做任何我们不希望发生的事情。
2. 操作系统如何切换进程。

### 3.2 受限制的操作

==关键问题：操作系统和硬件如何让进程能够执行某种受限制的操作（如发起*I/O*请求等），但是又不能让进程完全控制操作系统。==

前提：硬件通过提供不同的执行模式来协助操作系统，在**用户模式**下，进程不能完全访问硬件资源，在**内核模式**下，操作系统可以完全访问硬件资源。

* 如何让用户执行某些特权操作，答案是借助操作系统的系统调用。

1. 执行系统调用时，程序执行陷阱指令，该指令跳入内核并将特权级别提升到内核模式，
2. 进入内核后，系统执行需要做的工作，完成后，操作系统调用一个陷阱返回指令。

* 操作系统如何找到这些系统调用的代码，内核通过启动陷阱表来实现。

1. 操作系执行某种特殊的指令通知硬件在发生某些异常时需要执行哪些代码。
2. 硬件记住处理程序的位置直到下一次机器重启。

### 3.3 进程切换

关键问题：操作系统如何重获CPU的控制器，以使它可以在进程之间进行切换。

* 协作方式，通过系统调用。
* 非协作方式，操作时钟中断。

进程切换时也要注意两个问题：

* 继续运行当前程序还是切换到另外一个程序，这由调度器来决定。

* 如何保存和恢复上写文，操作系统底层会保存当前进程寄存器的值和内核栈指针并恢复下一个进程寄存器，内核栈。

## 4.进程调度

### 4.1 调度指标

周转时间：
$$
T_{响应时间} = T_{完成时间}-T_{到达时间}
$$
响应时间：
$$
T_{响应时间} = T_{首次运行}-T_{到达时间}
$$

### 4.2 调度策略

#### 4.2.1先进先出（FIFO）

#### 4.2.2最短任务优先（SJF）

#### 4.2.3最短完成时间优先（STCF）

#### 4.2.4时间片轮转（RR）

### 4.3 多级反馈队列

## 5.地址空间和转换

